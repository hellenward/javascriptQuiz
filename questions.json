{
  "questions": [
    {
      "questionNumber": 1,
      "question": "What is a high level language?",
      "incorrectAnswers": [
        "It only works at an altitude of 5,000 feet or higher",
        "It is the favoured languages of important people like executives",
        "You don't need to know how it works, just that it does"
      ],
      "correctAnswer": "It contains abstractions to manage hardware resources for you, you don't have to worry about it",
      "moreInfo": "There are a low level languages, such as C, which requires the user to manage hardware resources such as memory or CPU. High level languages, such as Javascript, do not require this as they contain abstractions to do that job for us. This has its advantages but the downside is that it may not be as fast or optimised as some of the lower level languages."
    },
    {
      "questionNumber": 2,
      "question": "What is garbage collection?",
      "incorrectAnswers": [
        "The people who come and take my rubbish away once a week or so",
        "Javascript will delete the repo once I'm finished using it",
        "Javascript will delete incorrect or duplicate code from your repo as it compiles so you don't end up with bloated code"
      ],
      "correctAnswer": "It helps your computer by removing old unused objects from its memory",
      "moreInfo": "It’s an algorithm inside of the JS engine which removes old unused objects from the computer memory so it doesn’t clog up your computer."
    },
    {
      "questionNumber": 3,
      "question": "How does Javascript turn human language code into computer code?",
      "incorrectAnswers": [
        "It's not Javascript, the keyboard does it automatically.",
        "You need a separate programme that works with Javascript and has to be running on your machine at the same time as you're writing/testing your code.",
        "Computers and humans speak the same language."
      ],
      "correctAnswer": "This is dealt with by the Javascript Engine and uses just-in-time compilation.",
      "moreInfo": "Javascript used to be a purely interpreted language, meaning an interpreter would run through the source code and execute it line by line, but this resulted in low performance which in modern times is not so acceptable. These days it uses a mix of compilation and interpretion - it compiles the whole source code and runs it immediately."
    },
    {
      "questionNumber": 4,
      "question": "What do we mean when we say Javascript is multi-paradigm?",
      "incorrectAnswers": [
        "It means you can mix it up with other programming languages.",
        "It means you can run several Javascript programmes at the same time with no CPU issues.",
        "It means variables can change their type several times depending on what you need them to do."
      ],
      "correctAnswer": "Javascript is procedural, object-orientated and functional and this makes it much more flexible.",
      "moreInfo": "A paradigm is a way of structuring our code which ultimately directs our coding style."
    },
    {
      "questionNumber": 5,
      "question": "Prototype-based object-orientated - want to take a guess what that means?",
      "incorrectAnswers": [
        "The whole of Javascript is a prototype.",
        "Objects need to be written as prototypes in order for Javascript to work. This can be done in the package.json file.",
        "You need to declare everything as an object before you can run your code."
      ],
      "correctAnswer": "There are some objects always available to us in Javascript (prototypes) which come with pre-defined methods - e.g. arrays always include the push() method.",
      "moreInfo": "Almost everything in Javascript is an object, apart from primative values like numbers and strings. Methods on objects, such as array.push() are known as prototypal inheritance."
    },
    {
      "questionNumber": 6,
      "question": "What are first class functions?",
      "incorrectAnswers": [
        "Functions that have precedence over other (second and third class) functions. This helps the Javascript engine decide which functions to execute first.",
        "Functions that call other functions within the code.",
        "Functions that get called first, before the rest of the code begins to execute."
      ],
      "correctAnswer": "Functions are treated like variables. We can pass functions into functions and can also return functions from other functions. There are a lot of functions in this sentence.",
      "moreInfo": "Functions are treated like variables. This is very powerful and allows us to adopt functional programming - one of the paradigms mentioned in an earlier question."
    },
    {
      "questionNumber": 7,
      "question": "What do we mean when we say Javascript is dynamically typed?",
      "incorrectAnswers": [
        "Variables of some types get on better with variables of the same type.",
        "You can have wildcard variables that can stand in for other kinds of variables - like the blank key in Scrabble.",
        "You can use variables in more than one file type in your code."
      ],
      "correctAnswer": "We don't need to assign data types to variables when they're declared, this only becomes known once the code is executed. Also types can change depending on what we need from the variable.",
      "moreInfo": "There is some discussion on whether this is good or bad. A lot of other languages require variables to have their data types declared up front, and this prevents bugs further along the line. If you want to use Javascript in a more strongly-typed manner, check out Typescript."
    },
    {
      "questionNumber": 8,
      "question": "What do we mean when we say Javascript is single-thread?",
      "incorrectAnswers": [
        "It uses thread as one of its datatypes.",
        "You have to be careful not to get your functions tangled up.",
        "It stands for T-head, or table-head. All tables in Javascript have to have a header."
      ],
      "correctAnswer": "It can only run one task at a time, in a single thread.",
      "moreInfo": "If you're wondering how it handles multiple tasks at the same time, this is possible due to the concurrency model. Next question!"
    },
    {
      "questionNumber": 9,
      "question": "Javascript will take long running tasks, execute them and then put them back into the main thread when they're ready. What is this process known as?",
      "incorrectAnswers": ["Multitasking", "Non-event block loop.", "The Javascript Engine."],
      "correctAnswer": "Non-blocking event loop.",
      "moreInfo": "More on this later..."
    },
    {
      "questionNumber": 10,
      "question": "What is the Javascript engine?",
      "incorrectAnswers": [
        "It's contained within your computer and runs your code.",
        "It takes your code on a journey - Javascript road trip anyone?",
        "It's very much like a server - there are several in the world that run all the Javascript in their local areas."
      ],
      "correctAnswer": "It comes with whichever browser you're using and runs your code.",
      "moreInfo": "Examples include Google V8."
    },
    {
      "questionNumber": 11,
      "question": "What are the componoents of a Javascript Engine?",
      "incorrectAnswers": [
        "The heap and the data flow.",
        "The call stack and the non-blocking event loop",
        "The heap and big data."
      ],
      "correctAnswer": "The call stack and the heap.",
      "moreInfo": "The call stack is where the data is executed. The heap is an unstructured memory pool which stores all the objects our application needs."
    },
    {
      "questionNumber": 12,
      "question": "Step 1: Parsing. Javascript parses the original code and passes it to the ",
      "incorrectAnswers": ["Javascript Engine.", "Call stack.", "Goalie."],
      "correctAnswer": "Abstract Syntax Tree (AST).",
      "moreInfo": " This splits each line of code into pieces that are meaningful for the language like the const or function keywords and then save it into the tree in a structured way. It also checks for syntax errors. This is then used later to generate the machine code."
    },
    {
      "questionNumber": 13,
      "question": "Step 2: Compilation. What's special about the way Javascript compiles code?",
      "incorrectAnswers": [
        "It spots and deletes code it doesn't need, thereby saving your computer's resources and helping the browser to run more efficiently.",
        "It does it without being told to do it - no instructions, no command line etc. It's all automatic.",
        "There isn't anything special about it. It does the same thing any other language would do."
      ],
      "correctAnswer": "It creates an un-optimised version of the code so it can start executing immediately and then optimises and re-compiles in the background while it's running, sweeping out non-optimised for optimised as it goes.",
      "moreInfo": "In this way, it is both compiled and interpreted! Also known as just-in-time compilation."
    },
    {
      "questionNumber": 13,
      "question": "Step 3: What is javascript run time?",
      "incorrectAnswers": [
        "The speed at which your programme executes.",
        "The command you have to type to start your code after it's been compiled.",
        "A cool band from the 90s. They had a top ten hit once..."
      ],
      "correctAnswer": "This is the container that contains all the things you need to use Javascript.",
      "moreInfo": "This includes the Javascript Engine itself, the web APIs and the call back queue"
    },
    {
      "questionNumber": 14,
      "question": "Step 3: How does the call back queue and call stack work?",
      "incorrectAnswers": [
        "Events are put up onto the cloud by the Javascript engine. The stack keeps a reference to them and retrieves them when needed.",
        "The call stack is a list of phone numbers. When an event is called, the call back happens.",
        "The call back queue takes your methods and orders them by size and resources needed to complete their corresponding events. The call stack will execute events in ascending order of size."
      ],
      "correctAnswer": "Events are stored in the call back queue until the call stack is empty. The event will then be put into the call stack and executed.",
      "moreInfo": "This is also known as the event loop and is essential for the non-blocking concurrency model."
    },
    {
      "questionNumber": 15,
      "question": "Step 3: A global execution context is created. How many global execution contexts are there?",
      "incorrectAnswers": [
        "4 - one for each step of the run time process.",
        "It depends on how many functions you have.",
        "The global execution context gets deleted once the code is executed, so the answer is 0."
      ],
      "correctAnswer": "1, but every function call will have its own execution context as well.",
      "moreInfo": "An execution context is an environment in which a piece of Javascript is executed. The global execution context is created for the top level code only - this includes code that is not inside any function. There is only one global execution context and it's always there as the default context."
    },
    {
      "questionNumber": 16,
      "question": "Step 3: What's inside an execution context?",
      "incorrectAnswers": [
        "All of the code.",
        "A list of methods the Javascript Engine will need to execute",
        "The this keyword and a map of the DOM so it can navigate through the code."
      ],
      "correctAnswer": "A variable environment, the scope chain and the this keyword.",
      "moreInfo": "The variable environment contains all of our variables, plus an arguments object containing all of the arguments that are passed into the function that the current execution belongs to. The scope chain contains references to variables outside of the current function. The this keyword will be covered later."
    },
    {
      "questionNumber": 17,
      "question": "Step 3: How are arrow functions different in relation to executions contexts?",
      "incorrectAnswers": [
        "It's written differently and therefore the execution context needs to execute it in a different way.",
        "It's covered by the global execution context instead of having its own execution context like any other kind of function would.",
        "It doesn't need a this keyword because the syntax of the arrow function makes this redundant."
      ],
      "correctAnswer": "They don't get their own arguments object or this keyword. Instead they use the ones from the nearest regular function parent.",
      "moreInfo": "This is an important difference to remember about arrow functions!"
    },
    {
      "questionNumber": 18,
      "question": "Step 4: Fill in the blank. When a function is called, it gets its own execution context. This is put into the ________________ on top of the global execution context.",
      "incorrectAnswers": ["Queue", "Javascript Engine", "Heap"],
      "correctAnswer": "Call stack",
      "moreInfo": "The call stack acts like a queue. As functions are called, they get added to the call stack. The programme takes whichever execution context is at the top of the call stack and executes it, then moves onto the next one. When functions are called within functions, their execution context is created and added to the pile. It will always start with the global execution context and work its way through the code, returning to it once it runs out of function execution contexts. Once there are no more functions, it will wait until the programme is finished or more functions are called via events such as clicks."
    },
    {
      "questionNumber": 19,
      "question": "What is scoping?",
      "incorrectAnswers": [
        "It's the reach or scope of an individual function. Some functions can only see certain files in the code and therefore they have no way of mutating data in other files.",
        "It's the size of a function. Some functions are a lot bigger and more complicated than others, and we therefore say they have a larger scope.",
        "It's the size of a variable. If they contain a lot of data, more scope is required to store them."
      ],
      "correctAnswer": "It's the space or environment in which a variable is declared and dictates which variables are available to which functions.",
      "moreInfo": "Javascript uses lexical scoping which means the way variables are organised and accessed is entirely controlled by the placement of functions and blocks in the code. A function written inside another function has access to its parent function's variables and the gloibal variables written outside of functions."
    },
    {
      "questionNumber": 20,
      "question": "What's the difference between global scope and function scope?",
      "incorrectAnswers": [
        "There is no difference.",
        "Global scope relates to all variables. Function scope relates to the functions themselves.",
        "Function scope relates specifically to arrow functions. Global scope is everything else."
      ],
      "correctAnswer": "Global scope relates to variables declared outside of functions. Function scope relates to variables inside functions. Functions can access global scope variables, but global cannot access functional scope variables unless they're returned and stored.",
      "moreInfo": "The variable environment contains all of our variables, plus an arguments object containing all of the arguments that are passed into the function that the current execution belongs to. The scope chain contains references to variables outside of the current function. The this keyword will be covered later."
    },
    {
      "questionNumber": 21,
      "question": "Starting from ES6, block scope has been introduced. What is block scope?",
      "incorrectAnswers": [
        "It relates to a new kind of object called block. You have to declare a block and then the variables inside that block will only relate to the block itself and not outside it.",
        "You can declare a variable to be private and therefore it blocks the scope and stops other functions from accessing it. This prevents bugs.",
        "You can declare a variable outside of a function, but tell it that it only relates to a certain function. Other functions are therefore blocked from accessing it."
      ],
      "correctAnswer": "It relates to anything that is inside curly braces. Variables declared inside curly braces are accessible inside the block and not outside.",
      "moreInfo": "Also starting in ES6, all functions are now also block scoped which means that functions declared inside a block are also accessible only inside the block."
    },
    {
      "questionNumber": 22,
      "question": "What is the difference scope-wise between let, const and var?",
      "incorrectAnswers": [
        "From ES6, var and let are block scoped. Const is function scoped.",
        "From ES6, let and const are globally scoped, var is function or block but never global anymore.",
        "There is no difference, but before ES6 there used to be. ES6 brought var into line with the others, and now all are block scoped."
      ],
      "correctAnswer": "From ES6, let and const are block scoped. Var is function scoped.",
      "moreInfo": "If a var is declared inside a block, it will still be accessible outside of the block."
    },
    {
      "questionNumber": 23,
      "question": "What is hoisting?",
      "incorrectAnswers": [
        "This is a sailing term and nothing to do with Javascript - you can't fool me!",
        "The Javascript Engine will prioritise functions and hoist them to the top of the call stack.",
        "This means the compiation process is complete and we're good to go."
      ],
      "correctAnswer": "Hoisting makes some kinds of variables availabe in the code before they are declared.",
      "moreInfo": "The code is scanned during the creation phase for variable declarations and a new property is created in the variable environment of the execution context."
    },
    {
      "questionNumber": 24,
      "question": "If you try to access a function declaration before it is fully declared in the code (i.e. function functionName() {...}), what will happen?",
      "incorrectAnswers": [
        "You will get a console message saying it is undefined.",
        "You will get a console error saying you cannot access a function declaration before initialisation.",
        "Nothing will happen."
      ],
      "correctAnswer": "It will call the function.",
      "moreInfo": "That is because function declarations are hoisted and stored in the variable environment as itself, hence why it is available immediately. This is what hoisting was made for!"
    },
    {
      "questionNumber": 24,
      "question": "What happens if you try to access a variable declard with var before it is defined?",
      "incorrectAnswers": [
        "You will get a console.error saying you cannot access a function declaration before initialisation.",
        "It will give you the variable definition defined further down.",
        "Nothing will happen."
      ],
      "correctAnswer": "You will get a console message saying the variable is undefined.",
      "moreInfo": "This is one of those things which seemed like a good idea at the time and now cannot be changed. It can cause some unwanted behaviour because undefined is not the same as uninitialised and therefore if you're relying on a var it will present as false until the code recompiles with the value you want it to be. This is why it's best to avoid var if at all possible."
    },
    {
      "questionNumber": 25,
      "question": "What happens if you try to access a variable declared with let or const before it is defined?",
      "incorrectAnswers": [
        "It will give you the variable definition defined further down.",
        "Nothing will happen.",
        "You will get a console message saying the variable is undefined."
      ],
      "correctAnswer": "You will get a console.error saying you cannot access a function declaration before initialisation.",
      "moreInfo": "Technically these are hoisted but their value is set to uninitialised so in practice it helps to think of them as not hoisted. They are placed in a TDZ until they are defined."
    },
    {
      "questionNumber": 26,
      "question": "What happens if you try to access a function expression or arrow function before it is defined?",
      "incorrectAnswers": [
        "It will execute the function as defined further down.",
        "You will get a console.error saying you cannot access a function declaration before initialisation.",
        "You will get a console message saying the variable is undefined."
      ],
      "correctAnswer": "It depends on whether you've declared it with let, const or var.",
      "moreInfo": "Var will be hoisted to undefined, but let or const will not be usable before it’s declared in the code because of the TDZ."
    },
    {
      "questionNumber": 27,
      "question": "What is the Temporal Dead Zone?",
      "incorrectAnswers": [
        "Something from Dr Who.",
        "The time between the start of a project and the developer starting to write the code.",
        "It's an infinite loop - a common error for beginners."
      ],
      "correctAnswer": "It's the place const and let variables get stored until they are fully initialised",
      "moreInfo": "The Temporal Dead Zone or TDZ was created to make it easier to catch errors. It is bad practice to try and access a variable before it is defiend, and the easiest way to do this is to make it create an error - in this case saying that the variable has not yet been initialised."
    },
    {
      "questionNumber": 28,
      "question": "Now onto a few questions about the this keyword... first up, what is it?",
      "incorrectAnswers": [
        "It's a variable that comes with the Javascript Engine.",
        "It's built into Javascript. You can mostly ignore it unless you're trying to make functions do something they're not designed to do.",
        "It's something you have to define in every function or your code will break."
      ],
      "correctAnswer": "It's a special variable that gets created in every execution context in the creation phase.",
      "moreInfo": "This means every function has its own this keyword, but the value is not static. It varies depending on how the function is called and its value is only assigned when the function is called."
    },
    {
      "questionNumber": 29,
      "question": "What does the this keyword point to in an arrow function?",
      "incorrectAnswers": [
        "Nothing because it doesn't have a this keyword.",
        "It points to itself.",
        "It always points to the window environment as it strictly doesn't have its own this keyword"
      ],
      "correctAnswer": "It points to its parent or surrounding function.",
      "moreInfo": "This is known as the lexical this keyword."
    },
    {
      "questionNumber": 30,
      "question": "What does the this keyword point to in a method or function attached to an object?",
      "incorrectAnswers": [
        "Nothing.",
        "It points to itself.",
        "It points to any children it may have, and if it doesn't it points to the window object."
      ],
      "correctAnswer": "It points to the object that is calling the method",
      "moreInfo": "So kind of like its parent as well!"
    },
    {
      "questionNumber": 31,
      "question": "What does the this keyword point to in a simple function call?",
      "incorrectAnswers": ["Its parent element", "It points to itself.", "The DOM element it wants to manipulate."],
      "correctAnswer": "It will be undefined as long as you're in strict mode",
      "moreInfo": "You are in strict mode, right?"
    },
    {
      "questionNumber": 32,
      "question": "What does the this keyword point to in an event listener?",
      "incorrectAnswers": [
        "Its parent element as long as it has one.",
        "It points to itself.",
        "It always points to the window environment as it strictly doesn't have its own this keyword"
      ],
      "correctAnswer": "It points to the DOM element its attached to",
      "moreInfo": "Makes sense, right?"
    },
    {
      "questionNumber": 33,
      "question": "Why should you avoid using an arrow function as a method in an object literal?",
      "incorrectAnswers": [
        "You can, as long as you specifically define this.",
        "Because it's not really a method, it's a function.",
        "Because it will cause an infinite loop."
      ],
      "correctAnswer": "Because it doesn't have its own this keyword and object literals don't have their own scope.",
      "moreInfo": "Chances are you'll end up using the this keyword of the window object which is probably not what you were after. Use a regular function instead."
    },
    {
      "questionNumber": 34,
      "question": "You have a method in an object literal, and inside that are using a regular function declaration to create another method. You try to use this, but it returns undefined. Why? How would you fix it?",
      "incorrectAnswers": [
        "This is because a function declaration will have an undefined this keyword in strict mode. You can fix this by moving everything into the global scope.",
        "Because you shouldn't use function expressions inside an object literal. You can fix this by turning the parent element into an arrow function.",
        "This should work. Maybe go and ask on Stack Overflow."
      ],
      "correctAnswer": "The this keyword will be undefined for a function declaration in strict mode. You can fix this by using an arrow function in this case as it's inside another method.",
      "moreInfo": "Remember: function declarations are better as direct children of object literals, but if they have children and you want to access this, you need to have the child be an arrow function."
    }
  ]
}
